<?xml version="1.0" encoding="utf-8"?>
<?xyl-use href="../Definitions.xyl"?>

<definition xmlns="http://hoa-project.net/xyl/xylophone">
<yield name="chapter">


  <h1 id="Model">Manuel d'apprentissage<title_break />XYL</h1>

  <ul class="prev_next">
    <li><a href="@ll:chapter=Model"><previous_chapter /> Modèle de
        données</a></li>
    <li>??? <next_chapter/></li>
  </ul>

  <p>Le système d'interface graphique permet de déclarer des
  <strong>vues</strong>. Il peut se cantonner à un simple affichage de données
  de manière ordonnée ou alors offrir bien plus de services, notamment sur la
  <strong>maintenance</strong>. Dans ce chapitre, nous allons présenter
  la bibliothèque <code>Hoa\View</code> et la bibliothèque
  <code>Hoa\Xyl</code>.</p>

  <h2 id="Table_des_matieres" for="menu-toc">Table des matières</h2>

  <tableofcontents id="main-toc" />

  <h2 id="Introduction" for="main-toc menu-toc">Introduction</h2>

  <p>D'une manière générale, le mécanisme d'un système de vue est le suivant : à
  partir de <strong>données</strong> sous différentes formes, nous allons créer
  une <strong>vue</strong>, l'agencer, la modifer, la mélanger aux données, puis
  en faire un rendu. Un <strong>rendu</strong> est comparable à peindre notre
  vue, <ie /> nous voulons en avoir un résultat partiel ou total. Ce résultat
  est affiché ou stocké, ce qui est dans tous les cas comparable à l'envoyer sur
  un flux. Enfin, un besoin annexe mais indispensable aux vues est la présence
  d'un <strong>routeur</strong>. En effet, les vues ont besoin de connaître les
  accès aux différentes ressources voire de localiser d'autres vues.</p>
  <p>Les besoins en terme d'interface graphique sont <strong>nombreux</strong>
  et très <strong>variés</strong> selon les contextes d'utilisation. C'est
  pourquoi il existe plusieurs outils. Dans un souci d'ouverture et
  d'uniformité, la bibliothèque <code>Hoa\View</code> ne définit qu'une seule
  interface : <code>Hoa\View\Viewable</code> qui définit quatre méthodes :</p>
  <ul>
    <li><code>getOutputStream</code> pour connaître le flux sur lequel la vue va
    être rendue ;</li>
    <li><code>getData</code> pour obtenir les données de la vue ;</li>
    <li><code>render</code> pour effectuer un rendu de la vue ;</li>
    <li><code>getRouter</code> pour obtenir le routeur associé à la vue.</li>
  </ul>
  <p>Cette interface est suffisante pour représenter la majorité des systèmes
  d'interface graphique. Ainsi, il est envisageable de développer votre propre
  système ou de brancher un système existant au reste des bibliothèques de Hoa.
  Toutefois, pour plus de confort, un système d'interface graphique est proposé
  dans Hoa : XYL.</p>
  <p><strong>XYL</strong> signifie <em>XML Yielding Language</em>. C'est un
  langage XML qui se base sur la théorie des composants et mélange des
  paradigmes de plusieurs langages d'interface graphique ou de manipulation de
  données tels que <a href="http://w3.org/TR/html5">HTML</a>,
  <a href="https://developer.mozilla.org/en/XUL">XUL</a>,
  <a href="http://w3.org/TR/xslt20">XSLT</a>,
  <a href="http://w3.org/TR/xpath20">XPath</a>,
  <a href="http://w3.org/TR/CSS">CSS</a> etc.</p>

  <h3 id="Composants_et_bibliotheques_graphiques" for="main-toc">Composants et
  bibliothèques graphiques</h3>

  <p>XYL permet la création de <strong>composants</strong> graphiques
  <strong>exécutables</strong> et <strong>réutilisables</strong>. Ces composants
  peuvent être <strong>assemblés</strong> entre eux afin de construire des
  composants plus importants. Il est possible d'avoir des
  <strong>bibliothèques</strong> de composants graphiques centralisées,
  facilement partageables et maintenables. Une bibliothèque de composants par
  défaut existe et reprend toutes les balises d'HTML en y ajoutant les
  particularités de XYL. Nous parlons alors du vocabulaire de XYL, ou du nommage
  des composants. Un avantage non négligeable d'avoir repris le vocabulaire
  d'HTML est que l'<strong>apprentissage</strong> de XYL est quasiment nul,
  sachant que les particularités proposées sont <strong>simples</strong> mais
  puissantes.</p>

  <h3 id="Yielding" for="main-toc"><em>Yielding</em></h3>

  <p>Le « Y » de XYL signifie <em>yielding</em>, <ie /> que XYL est un langage
  de production. Le mécanisme de <em>yielding</em> <strong>propre à XYL</strong>
  est bien adapté aux problématiques des systèmes d'interface graphique. Par
  exemple, lors de la création d'un composant graphique, ce dernier ne connait
  pas la quantité de données qu'il va devoir produire ; il n'en connaît que la
  forme (nous détaillerons cette partie plus loin). Il ne connaît pas non plus
  le contexte dans lequel il va être utilisé et encore moins à quels composants
  il sera associé.</p>
  <p>Cette approche facilite l'<strong>écriture</strong> de composants
  graphiques, le <strong>partage</strong> de tous ces composants entre plusieurs
  projets et leur <strong>maintenance</strong>.</p>

  <h3 id="Multi-plateformes_et_multi-sorties" for="main-toc">Multi-plateformes
  et multi-sorties</h3>

  <p>Nous avons dit que XYL était exécutable. Mieux encore, c'est un langage
  <strong>interprété</strong> : en fonction de la plateforme ou du type de
  sortie (applications Web, applications de bureau, de tablette, de téléphone,
  de télévision, un terminal, un
  <a href="https://www.adobe.com/devnet/pdf/pdf_reference_archive.html">PDF</a>
  etc.), nous allons choisir un interpréteur et l'exécuter sur nos documents
  XYL. Le résultat sera normalement celui attendu.</p>

  <h2 id="Document" for="main-toc menu-toc">Document</h2>

  <p>Pour introduire XYL, nous allons commencer par créer un document à l'aide
  du <strong>composant racine</strong> <code>document</code> dans un fichier que
  nous nommerons <code>Main.xyl</code>. Tous les documents ou composants XYL
  travaillent sur l'<strong>espace de nom XML</strong>
  <code>http://hoa-project.net/xyl/xylophone</code> (attention à la casse). À ce
  document, nous allons définir un titre grâce au composant <code>title</code>,
  et enfin nous allons ajouter un paragraphe avec une liste non-ordonnée grâce
  aux composants <code>p</code>, <code>ul</code> et <code>li</code> :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;p>This is my first XYL document! XYL is:&amp;lt;/p>
  &amp;lt;ul>
    &amp;lt;li>easy to learn;&amp;lt;/li>
    &amp;lt;li>simple;&amp;lt;/li>
    &amp;lt;li>powerful.&amp;lt;/li>
  &amp;lt;/ul>
&amp;lt;/document></code></pre>
  <p>Nous allons maintenant interpréter ce document.</p>

  <h3 id="Interpretation" for="main-toc">Interprétation</h3>

  <p>Pour interpréter XYL, nous avons besoin de la classe <code>Hoa\Xyl</code>
  qui va préparer nos documents ainsi que nos données, et lancer le rendu de
  notre interprétation. XYL a besoin au minimum de :</p>
  <ul>
    <li>un flux d'entrée, pour lire le document XYL ;</li>
    <li>un flux de sortie, pour écrire le rendu de l'interprétation ;</li>
    <li>un interpréteur, représenté par la classe abstraite
    <code>Hoa\Xyl\Interpreter</code>.</li>
  </ul>
  <p>Nous allons commencer avec l'interpréteur HTML qui est le plus simple à
  déployer, représenté par la classe <code>Hoa\Xyl\Interpreter\Html</code>.
  Notre flux de sortie sera représenté par la classe
  <code>Hoa\Http\Response</code>. Ainsi, créons le fichier
  <code>index.php</code> :</p>
  <pre><code language="php">from('Hoa')
-> import('File.Read')
-> import('Http.Response')
-> import('Xyl.~')
-> import('Xyl.Interpreter.Html.~');

$xyl = new Hoa\Xyl(
    new Hoa\File\Read('Main.xyl'),
    new Hoa\Http\Response(),
    new Hoa\Xyl\Interpreter\Html()
);
$xyl->render();</code></pre>
  <p>Il suffit maintenant d'exécuter ce fichier PHP pour observer le
  résultat :</p>
  <pre><code language="shell">$ php index.php</code></pre>
  <p>Ou depuis un navigateur (à l'aide de Bhoa par exemple) :</p>
  <pre><code language="shell">$ myapp bhoa --root .</code></pre>
  <p>puis en ouvrant l'URL
  <a href="http://127.0.0.1:8888"><code>127.0.0.1:8888</code></a>.</p>
  <p>Nous vous conseillons d'essayer de modifier ce document XYL comme si
  c'était de l'HTML pour vous rendre compte que le vocabulaire est le même (par
  exemple en ajoutant des identifiants, des classes, d'autres composants/balises
  etc.)</p>

  <h3 id="Feuilles_de_style" for="main-toc">Feuilles de style</h3>

  <p>L'objectif de XYL est de définir la <strong>structure</strong> et une
  partie du <strong>comportement</strong> d'un document mais jamais il ne
  définira son style. Ce travail doit être réalisé par un autre langage, de
  préférence <a href="http://www.w3.org/TR/CSS">CSS</a> mais ce n'est pas
  obligatoire, le choix étant laissé à l'utilisateur.</p>
  <p>Pour déclarer une feuille de style, nous utilisons la
  <a href="http://w3.org/TR/xml11/#sec-pi"><em>processing-instruction</em></a>
  <code>&amp;amp;lt?xyl-stylesheet?></code> en tête de n'importe quel document
  XYL avec son attribut <code>href</code> pour préciser l'emplacement de notre
  feuille de style. Nous parlons d'une <strong>déclaration statique</strong>.
  Ainsi :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-stylesheet href="UI.css"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>
  …</code></pre>
  <p>Et notre fichier <code>UI.css</code> :</p>
  <pre><code language="css">body {
    color: red
}</code></pre>
  <p>Maintenant, réouvrons
  <a href="http://127.0.0.1:8888"><code>127.0.0.1:8888</code></a> et nous
  observons que notre document a changé de style.</p>
  <p>Nous pouvons déclarer <strong>dynamiquement</strong> une feuille de style
  en utilisant la méthode <code>addStylesheet</code> de la classe
  <code>Hoa\Xyl</code>. Ainsi, le code suivant produira le même résultat :</p>
  <pre><code language="php">$xyl = new Hoa\Xyl(
    new Hoa\File\Read('Main.xyl'),
    new Hoa\Http\Response(),
    new Hoa\Xyl\Interpreter\Html()
);
$xyl->addStylesheet('UI.css');
$xyl->render();</code></pre>

  <h2 id="Overlay" for="main-toc menu-toc"><em>Overlay</em></h2>

  <p>Les <strong><em>overlays</em></strong> sont un ou plusieurs composants que
  nous voulons <strong>insérer</strong> dans un document. Par exemple, imaginons
  une application qui présente un contenu et une colonne sur le côté contenant
  plusieurs extensions que l'utilisateur de l'application peut installer comme
  il le souhaite. Chaque extension est définie comme un <em>overlay</em> qui ne
  sait pas comment est construit le document principal, mais il connaît
  l'<strong>identifiant</strong> de la colonne contenant les extensions. Cette
  information est amplement suffisante ! Ainsi, lorsque l'extension va
  s'installer, l'application n'aura qu'à déclarer un nouvel <em>overlay</em>
  dans le document et il bénéficiera de <strong>toutes les ressources</strong>
  du document. En plus de préciser où s'accrocher par rapport à un composant, il
  peut préciser sa position dans ce composant.</p>
  <p><em>À l'instar</em> d'une déclaration de feuille de style, une déclaration
  d'<em>overlay</em> se fait avec une <em>processing-instruction</em> :
  <code>&amp;amp;lt;?xyl-overlay?></code> en tête de n'importe quel document
  XYL et avec son attribut <code>href</code> pour préciser l'emplacement de
  notre <em>overlay</em>. De même, pour une déclaration dynamique, nous avons la
  méthode <code>addOverlay</code> sur la classe <code>Hoa\Xyl</code>. Ainsi,
  nous déclarons l'<em>overlay</em> contenu dans le fichier
  <code>Extension.xyl</code> à notre document auquel nous avons ajouté un
  composant portant l'identifiant <code>extensions</code> et accueillant déjà
  une extension :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-stylesheet href="UI.css"?>
&amp;lt;?xyl-overlay href="Extension.xyl"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;article>
    &amp;lt;h1>My blog&amp;lt;/h1>
    &amp;lt;p>This is my blog.&amp;lt;/p>
  &amp;lt;/article>

  &amp;lt;aside id="extensions">
    &amp;lt;h1>Extensions&amp;lt;/h1>
    &amp;lt;div id="bar">
      &amp;lt;h2>Bar&amp;lt;/h2>
      &amp;lt;p>Awesome bar.&amp;lt;/p>
    &amp;lt;/div>
  &amp;lt;/aside>
&amp;lt;/document></code></pre>
  <p>Nous avons précisé que tous les documents XYL peuvent déclarer des
  <em>overlays</em>, ce qui signifie qu'un <em>overlay</em> peut utiliser
  d'autres <em>overlays</em> et ainsi de suite, mais tous s'appliqueront sur le
  document final.</p>

  <h3 id="Composition_d-un_overlay" for="main-toc">Composition d'un
  <em>overlay</em></h3>

  <p>Étudions maintenant la <strong>composition</strong> d'un <em>overlay</em>.
  Tout d'abord, nous utilisons le <strong>composant racine</strong>
  <code>overlay</code>. Chaque fils de ce composant racine représente un
  <strong>composant de référence</strong> qui indique sur quel composant nous
  voulons nous <strong>accrocher</strong>. Chaque fils d'un composant de
  référence représente un <strong>composant à insérer</strong>.</p>
  <pre><code language="xml">&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;reference_component>
    &amp;lt;component_to_insert>…&amp;lt;/component_to_insert>
    &amp;lt;component_to_insert>…&amp;lt;/component_to_insert>
  &amp;lt;/reference_component>

  &amp;lt;reference_component>
    …
  &amp;lt;/reference_component>
&amp;lt;/overlay></code></pre>
  <p>Le composant de référence a besoin d'un <strong>identifiant</strong> pour
  correctement créer une référence vers le composant dans lequel il va insérer
  des nouveaux composant, parmi ceux déjà présents.</p>
  <p>Ajoutons une nouvelle extension dans notre colonne en écrivant dans notre
  fichier <code>Extension.xyl</code> :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;aside id="extensions">
    &amp;lt;div id="foo">
      &amp;lt;h2>Foo&amp;lt;/h2>
      &amp;lt;p>Awesome foo.&amp;lt;/p>
    &amp;lt;/div>
  &amp;lt;/aside>
&amp;lt;/overlay></code></pre>
  <p>Réinterprétons notre document principal et notre nouvelle extension est
  bien présente dans notre colonne ! Seulement, nous aurions aimé placer cette
  extension en tête de colonne et non pas à la suite des extensions déjà
  présentes.</p>

  <h3 id="Positionner_des_overlays" for="main-toc">Positionner des
  <em>overlays</em></h3>

  <p>Chaque composant à insérer possède l'attribut <code>position</code> qui
  permet de <strong>positionner</strong> notre <em>overlay</em> parmi les
  composants qui vont l'accueillir. Les valeurs sont constituées des expressions
  suivantes :</p>
  <ul>
    <li>un <strong>index</strong> supérieur ou égal à zéro (<code>0</code>,
    <code>1</code>, …, <code><em>n</em></code>) ;</li>
    <li>une <a href="http://w3.org/TR/xpath20/#id-arithmetic"><strong>opération</strong>
    arithmétique XPath</a>, soit : l'addition (<code>+</code>, unaire ou
    binaire), la soustraction (<code>-</code>, unaire ou binaire), la
    multiplication (<code>*</code>), la division (<code>div</code>), la division
    entière (<code>idiv</code>) et le modulo (<code>mod</code>) ;</li>
    <li>un index <strong>dynamique</strong> :
    <code>element(#<em>anId</em>)</code>, pour connaître la position d'un
    élément déjà existant ou <code>last()</code> pour la dernière
    position.</li>
  </ul>
  <p>Prenons quelques exemples concrets pour bien comprendre. Pour positionner
  un <em>overlay</em> :</p>
  <ul>
    <li>en première position : <code>0</code> ;</li>
    <li>en seconde position : <code>1</code> (nous devrions comprendre que
    l'insertion se fait à <strong>gauche</strong>) ;</li>
    <li>en dernière position : <code>last()</code> ;</li>
    <li>en avant-dernière position : <code>last() - 1</code> ;</li>
    <li>avant un composant portant l'identifiant <code>baz</code> :
    <code>element(#baz)</code> ;</li>
    <li>après un composant portant l'identifiant <code>baz</code> :
    <code>element(#baz) + 1</code> ;</li>
    <li>de manière non-logique : <code>last() - 2 * element(#qux) mod
    3</code> ;</li>
    <li>etc.</li>
  </ul>
  <p>Attention : l'<strong>ordre</strong> d'insertion des composants va influer
  leurs positions. Toutes les expressions de position sont évaluées au dernier
  moment, soit juste avant l'insertion. Une position négative sera réduite à
  <code>0</code>, une position trop grande sera réduite à <code>last()</code> et
  une position non-entière sera tronquée à sa partie entière.</p>
  <p>Ainsi pour positionner notre nouvelle extension <code>foo</code> non pas en
  dernière position mais en première position, nous aurons la position
  <code>1</code> (utiliser la position <code>0</code> la placerait avant le
  titre de notre colonne) :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;aside id="extensions">
    &amp;lt;div id="foo" position="1">
      &amp;lt;h2>Foo&amp;lt;/h2>
      &amp;lt;p>Awesome foo.&amp;lt;/p>
    &amp;lt;/div>
  &amp;lt;/aside>
&amp;lt;/overlay></code></pre>
  <p>En complément, nous voulons ajouter un séparateur entre nos deux extensions
  grâce au composant <code>hr</code>. Nous avons donc un second composant à
  insérer et nous le positionnerons après notre composant <code>foo</code> ;
  ainsi :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;aside id="extensions">
    &amp;lt;div id="foo" position="1">
      &amp;lt;h2>Foo&amp;lt;/h2>
      &amp;lt;p>Awesome foo.&amp;lt;/p>
    &amp;lt;/div>

    &amp;lt;hr position="element(#foo)" />
  &amp;lt;/aside>
&amp;lt;/overlay></code></pre>
  <p>Si la position de notre nouvelle extension est modifiée, son séparateur
  sera toujours après elle sans <strong>rien changer</strong>.</p>

  <h3 id="Overlays_et_feuilles_de_style" for="main-toc"><em>Overlays</em> et
  feuilles de style</h3>

  <p>Les <em>overlays</em> peuvent également déclarer des feuilles de style
  grâce aux mécanismes vus précédemment. Ainsi, nous pouvons imaginer
  avoir :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-stylesheet href="Extension.css"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;aside id="extensions">
    &amp;lt;div id="foo" position="1">
      …</code></pre>
  <p>Avec notre fichier <code>Extension.css</code> qui contiendrait :</p>
  <pre><code language="css">#foo {
    color: green
}</code></pre>
  <p>Après réinterprétation de notre document, le texte de notre extension aura
  un style différent. Ce mécanisme est intéressant si des extensions veulent
  <strong>embarquer</strong> leurs propres styles (ou d'autres ressources).</p>
  <p>Toutefois, nous noterons que les feuilles de style se comportent comme une
  <strong>pile</strong> : elles s'ajoutent les unes après les autres. Aussi bien
  avec les <em>overlays</em> qu'avec <strong>tous</strong> les autres documents,
  la déclaration d'une feuille de style peut <strong>se positionner</strong>
  grâce à l'attribut <code>position</code>. Nous retrouvons les mêmes
  expressions que pour l'attribut <code>position</code> des composants à insérer
  d'un <em>overlay</em>, excepté que l'index dynamique
  <code>element(#<em>anId</em>)</code> n'est pas supporté. Ainsi, si nous
  souhaitons que notre feuille <code>Extension.css</code> se place en première
  position, nous aurons :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-stylesheet href="Extension.css" position="0"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;aside id="extensions">
    &amp;lt;div id="foo" position="1">
      …</code></pre>
  <p>Les avantages sont nombreux. Par exemple, si nous définissons un ensemble
  de règles de style pour un composant graphique et que l'ajout d'un nouveau
  composant vient écraser ces règles, cela est gênant. Avec certains langages,
  comme CSS, nous trouvons l'instruction <code>!important</code> qui empêche la
  <strong>surchage</strong> d'une règle, mais cela peut parfois aboutir à des
  situations inconfortables pour une surchage <strong>future</strong>. De plus,
  il n'est pas toujours évident de connaître l'ensemble des règles
  <strong>impactées</strong> par une surcharge de style. Ainsi, pour éviter
  toute <strong>régression</strong> et problématique éventuelle, il est
  préférable de <strong>réordonner</strong> les déclarations de feuilles de
  style.</p>
  <p>Il est intéressant de constater que XYL ne redéfinit pas les positions des
  feuilles de style. Si nous avions déclaré la position <code>42</code> pour
  notre feuille <code>Extension.css</code>, elle aurait été la dernière feuille
  à être déclarée dans notre exemple, mais elle porterait toujours la position
  <code>42</code>. Ce qui signifie que si une nouvelle feuille se déclare avec
  la position <code>5</code>, elle se placerait avant. Il est alors possible
  d'envisager des <strong>plages</strong> de feuilles de style
  <strong>réservées</strong> à certaines tâches si une application devient
  importante ou hautement extensible. Par exemple : <code>[0;100[</code> pour
  des extensions, <code>[100;120[</code> pour la base, <code>[120;200[</code>
  pour le thème etc. Si les feuilles sont bien conçues, elles peuvent devenir
  facilement <strong>maintenables</strong>. Enfin, si deux règles ont la même
  position, la dernière viendra s'insérer à sa position et décale les
  précédentes vers le haut de la pile.</p>

  <h3 id="Un_peu_plus_loin_avec_les_overlays" for="main-toc">Un peu plus loin
  avec les <em>overlays</em></h3>

  <p>Un composant de référence est capable de <strong>modifier</strong> le
  composant dans lequel il va insérer de nouveaux composants : il peut lui
  ajouter ou modifier des attributs (mais pas en supprimer). Par exemple, si
  nous voulons ajouter un attribut <code>class</code> à notre colonne, nous
  ferons :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-stylesheet href="Extension.css"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;aside id="extensions" class="baz">
    &amp;lt;div id="foo" position="1">
      …</code></pre>
  <p>Selon le type d'attribut, le comportement s'adaptera. Dans le cas de
  l'attribut <code>class</code> (qui est de type liste), les nouvelles classes
  de style seront ajoutées aux existantes, alors que pour d'autres attributs, la
  valeur sera peut-être simplement remplacée.</p>

  <h2 id="Binding_et_yielding" for="main-toc menu-toc"><em>Binding</em> et
  <em>yielding</em></h2>

  <p>Le mécanisme de <strong>liage</strong> (ou
  <strong><em>binding</em></strong>) des données à notre vue est simple à
  comprendre et à utiliser si nous comprenons bien la <strong>forme</strong> de
  nos données.</p>

  <h3 id="Arbres_et_forets_de_donnees" for="main-toc">Arbres et forêts de
  données</h3>

  <p>XYL manipule des données qui ont la forme d'<strong>arbres</strong>. Pour
  simplifier la construction et la manipulation de ces arbres (et aussi pour des
  raisons de performance), XYL utilise la classe <code>Hoa\Core\Data</code>.
  Cette classe est hautement dynamique : tout se déclare à la volée (attributs,
  index de tableaux etc.). Initialement, elle permet de manipuler des données
  <strong>polymorphiques</strong> ; dans le cas de XYL nous voulons l'utiliser
  uniquement comme un ensemble d'arbres, soit une <strong>forêt</strong>.</p>
  <p>Pour débuter avec les données, nous avons besoin de définir la forme de
  notre arbre pour <strong>un seul</strong> exemplaire. Imaginons par exemple un
  arbre <code>article</code> représentant un article et comportant les données
  suivantes :</p>
  <ul>
    <li>un identifiant <code>id</code> ;</li>
    <li>un titre <code>title</code> ;</li>
    <li>un auteur <code>author</code>.</li>
  </ul>
  <p>Avec une instance de <code>Hoa\Core\Data</code> que nous récupérons avec la
  méthode <code>Hoa\Xyl::getData</code>, nous avons :</p>
  <pre><code language="php">$xyl  = new Hoa\Xyl(…);
$data = $xyl->getData();

$data->article->id     = 0;
$data->article->title  = 'Foobar';
$data->article->author = 'G. Freeman';

$xyl->render();</code></pre>
  <p>Essayons de <strong>lier</strong> ces données grâce à l'attribut
  <code>bind</code> qui se trouve sur <strong>tous</strong> les composants
  XYL. La syntaxe d'un liage est <code>?[p[ath]:]<em>aTreeName</em></code>. Ainsi :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;ul>
    &amp;lt;li bind="?article">
      #&amp;lt;value bind="?id" /> &amp;lt;cite bind="?title" /> — &amp;lt;em bind="?author" />
    &amp;lt;/li>
  &amp;lt;/ul>
&amp;lt;/document></code></pre>
  <p>Nous voyons que le composant <code>li</code> se <strong>lie</strong> à
  l'arbre <code>article</code>, puis de même pour chacun de ses sous-arbres (ici
  des feuilles), respectivement <code>id</code>, <code>title</code> et
  <code>author</code>. Nous découvrons en même temps le composant
  <code>value</code> qui sert à afficher une valeur verbatim. Nous déduisons
  alors que faire <code language="xml">&amp;lt;cite bind="?title" /></code> est
  strictement équivalent à faire <code language="xml">&amp;lt;cite>&amp;lt;value
  bind="?title" />&amp;lt;/cite></code>.</p>
  <p>Si nous interprétons notre document, nous verrons bien les données
  apparaître.</p>
  <p>Maintenant que nous avons notre arbre, nous allons créer une
  <strong>forêt</strong>. Il faut savoir que dans le monde de XYL, tous les
  arbres de la même espèce sont strictement <strong>identiques</strong> à part
  la couleur de leurs feuilles, <ie /> les données finales. C'est pourquoi si
  nous créons un nouvel arbre <code>article</code>, il aura la même forme que
  celui que nous venons de créer. Nous accédons aux différents arbres grâce à un
  index comme pour un tableau ; ainsi :</p>
  <pre><code language="php">$data->article[0]->id     = 0;
$data->article[0]->title  = 'Foobar';
$data->article[0]->author = 'G. Freeman';

$data->article[1]->id     = 1;
$data->article[1]->title  = 'Bazqux';
$data->article[1]->author = 'A. Vance';</code></pre>
  <p>Sans modifier notre fichier XYL, nous allons le réinterpréter. Nous voyons
  que notre forêt d'arbres <code>article</code> est <strong>itérée</strong>
  correctement.</p>
  <p>Nous aimerions maintenant que chaque article puisse avoir plusieurs
  auteurs, nous allons alors créer un nouveau sous-arbre <code>name</code> sous
  le sous-arbre <code>author</code> :</p>
  <pre><code language="php">$data->article[0]->id                 = 0;
$data->article[0]->title           = 'Foobar';
$data->article[0]->author->name[0] = 'G. Freeman';
$data->article[0]->author->name[1] = 'G-Man';

$data->article[1]->id              = 1;
$data->article[1]->title           = 'Bazqux';
$data->article[1]->author->name    = 'A. Vance';</code></pre>
  <p>Nous devons modifier notre document XYL pour qu'il prenne en considérations
  ce nouveau sous-arbre :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;ul>
    &amp;lt;li bind="?article">
      #&amp;lt;value bind="?id" /> &amp;lt;cite bind="?title" />
      &amp;lt;ul bind="?author">&amp;lt;li bind="?name" />&amp;lt;/ul>
    &amp;lt;/li>
  &amp;lt;/ul>
&amp;lt;/document></code></pre>
  <p>Les auteurs apparaissent comme attendus.</p>
  <p>Chaque composant qui fait un liage utilise un nouveau sous-arbre sur lequel
  ses sous-composants vont travailler.</p>
  <p>Cette forme de données peut paraître étrange au début mais elle s'adapte
  très bien aux outils d'<strong>extraction</strong> de données (comme les bases
  de données).</p>

  <h3 id="Inner-binding" for="main-toc"><em>Inner-binding</em></h3>

  <p>Nous avons vu l'attribut <code>bind</code> qui permet de lier le
  <strong>contenu</strong> d'un composant avec des données, mais nous pouvons
  également lier le contenu d'un <strong>attribut</strong> avec des données. Ce
  mécanisme s'appelle le <strong>liage-interne</strong> (ou
  <strong><em>inner-binding</em></strong>). Sa syntaxe est la même que pour un
  liage normal sauf que nous y ajoutons des parenthèses, soit :
  <code>(?[p[ath]:]<em>aTreeName</em>)</code>. Comme tous les composants sont
  liables, <strong>tous</strong> les attributs de tous les composants le sont
  également. Ainsi, nous pouvons modifier notre document existant en déplaçant
  la donnée <code>id</code> dans un attribut :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;ul>
    &amp;lt;li bind="?article">
      &amp;lt;cite bind="?title" id="title_(?id)" />
      &amp;lt;ul bind="?author">&amp;lt;li bind="?name" />&amp;lt;/ul>
    &amp;lt;/li>
  &amp;lt;/ul>
&amp;lt;/document></code></pre>

  <h3 id="Donnees_symboliques_et_definition_de_composants"
  for="main-toc">Données symboliques et définition de composants</h3>

  <p>Maintenant que nous connaissons la forme des données et le mécanisme de
  liage (verbatim ou interne), nous allons nous intéresser à la création de
  composants graphiques qui est une finalité de XYL. Les données sont découpées
  uniformément et sont dites <strong>isolées</strong> et <strong>libres de
  contexte</strong>, ou plus simplement nous parlons de <strong>données
  symboliques</strong>.</p>
  <p>Un nouveau composant qui est souvent utile dans XYL est <code>yield</code>.
  Ce composant peut avoir trois fonctions :</p>
  <ul>
    <li>permettre de positionner un <strong>liage</strong> particulier, grâce à
    l'attribut <code>bind</code>, déjà bien connu ;</li>
    <li>créer un <strong>composant</strong>, grâce à l'attribut
    <code>name</code> ;</li>
    <li>créer un composant <strong>dynamique</strong>, grâce à l'attribut
    <code>select</code>.</li>
  </ul>
  <p>En premier lieu, <code>yield</code> ne fera aucun rendu de lui-même mais
  uniquement de ses enfants s'ils existent ou alors de son liage. Ainsi, la
  modification suivante du document remplacera notre liste d'auteurs avec les
  composants <code>ul</code> et <code>li</code> par simplement <code>em</code>
  (<code>yield</code> n'apparaîtra pas) :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;ul>
    &amp;lt;li bind="?article">
      &amp;lt;cite bind="?title" id="title_(?id)" /> — 
      &amp;lt;yield bind="?author">
        &amp;lt;em bind="?name" />
      &amp;lt;/yield>
    &amp;lt;/li>
  &amp;lt;/ul>
&amp;lt;/document></code></pre>
  <p>Ensuite, si nous utilisons un <strong>composant nommé</strong>,
  c'est à dire un composant <code>yield</code> avec l'attribut
  <code>name</code>, alors nous créons un nouveau composant que nous pouvons
  réutiliser où nous voulons et autant de fois que nous le désirons. Par
  exemple, nous allons créer un composant nommé <code>author_article</code>,
  puis l'utiliser :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;yield name="author_article">
    &amp;lt;h1 bind="?title" id="title_(?id)" />
    &amp;lt;ul bind="?author">&amp;lt;li bind="?name" />&amp;lt;/ul>
  &amp;lt;/yield>

  &amp;lt;author_article bind="?article" />
&amp;lt;/document></code></pre>
  <p>Nous <strong>lions</strong> les données au composant
  <code>author_article</code> toujours grâce à l'attribut <code>bind</code>.
  Utiliser un attribut <code>bind</code> sur un composant <code>yield</code> qui
  porte un attribut <code>name</code> n'aura <strong>aucun</strong> effet mais
  peut servir de <em>memorandum</em> !</p>
  <p>Bien entendu, nous pouvons réutiliser nos composants dans de nouveaux
  composants et ainsi de suite (l'ordre n'a pas d'importance) :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;yield name="author_articles">
    &amp;lt;author_article />
    &amp;lt;hr />
  &amp;lt;/yield>

  &amp;lt;yield name="author_article">
    &amp;lt;h1 bind="?title" id="title_(?id)" />
    &amp;lt;ul bind="?author">&amp;lt;li bind="?name" />&amp;lt;/ul>
  &amp;lt;/yield>

  &amp;lt;author_articles bind="?article" />
&amp;lt;/document></code></pre>
  <p>Enfin, utiliser un <strong>composant sélecteur</strong>, c'est à dire un
  composant <code>yield</code> avec l'attribut <code>select</code>, n'est
  possible que dans un composant nommé. L'objectif est de sélectionner des
  composants lors de l'utilisation d'un composant nommé. La sélection se fait à
  l'aide d'une <a href="http://w3.org/TR/xpath20">expression XPath</a> de la
  forme <code>?x[path]:<em>expression</em></code> ou d'un
  <a href="http://w3.org/TR/css3-selectors">sélecteur CSS</a> de la forme
  <code>?q[uery]:<em>selector</em></code>. Par exemple, au lieu d'utiliser le
  composant <code>hr</code> de manière statique, nous allons sélectionner tous
  les composants fournis par l'utilisateur :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;yield name="author_articles">
    &amp;lt;author_article />
    &amp;lt;yield select="?x:*" />
  &amp;lt;/yield>

  &amp;lt;yield name="author_article">
    &amp;lt;h1 bind="?title" id="title_(?id)" />
    &amp;lt;ul bind="?author">&amp;lt;li bind="?name" />&amp;lt;/ul>
  &amp;lt;/yield>

  &amp;lt;author_articles bind="?article">
    &amp;lt;p>&amp;lt;a href="#">top&amp;lt;/a>&amp;lt;/p>
    &amp;lt;hr />
  &amp;lt;/author_articles>
&amp;lt;/document></code></pre>
  <p>Les composants sélectionnés peuvent également se lier aux données du
  composant dans lequel ils sont insérés :</p>
  <pre><code language="xml">  …
  &amp;lt;author_articles bind="?article">
    &amp;lt;p>End of &amp;lt;value bind="?title" />, go to &amp;lt;a href="#">top&amp;lt;/a>&amp;lt;/p>
    &amp;lt;hr />
  &amp;lt;/author_articles>
&amp;lt;/document></code></pre>
  <p>Ce mécanisme offre de belles opportunités.</p>


  <h3 id="Definition_de_bibliotheques_de_composants" for="main-toc">Définition
  de bibliothèques de composants</h3>

  <p>Nous savons créer des composants graphiques grâce aux composants nommés.
  Nous pouvons alors avoir des <strong>bibliothèques de composants
  graphiques</strong> stockées dans un ou plusieurs fichiers XYL.</p>
  <p><em>À l'instar</em> d'une déclaration de feuille de style ou d'un
  <em>overlay</em>, une utilisation d'une bibliothèque graphique se fait avec
  une <em>processing-instruction</em> : <code>&amp;amp;lt;?xyl-use?></code> en
  tête de n'importe quels documents XYL et avec son attribut <code>href</code>
  pour préciser l'emplacement de notre bibliothèque graphique. De même, pour une
  déclaration dynamique, nous avons la méthode <code>addUse</code> sur la classe
  <code>Hoa\Xyl</code>. Une bibliothèque peut bien sûr inclure d'autres
  bibliothèques et ainsi de suite. Une bibliothèque peut également déclarer des
  feuilles de style mais pas des <em>overlays</em>. Ainsi, si nous
  <strong>externalisons</strong> nos composants fraîchement créés :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-use href="Author.xyl"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;author_articles bind="?article">
    &amp;lt;p>&amp;lt;a href="#">top&amp;lt;/a>&amp;lt;/p>
    &amp;lt;hr />
  &amp;lt;/author_articles>
&amp;lt;/document></code></pre>
  <p>Enfin, notre bibliothèque graphique est contenue dans le <strong>composant
  racine</strong> <code>definition</code> et ne contient que des composants
  nommés. Voici notre fichier <code>Author.xyl</code> :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;definition xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;yield name="author_articles">
    &amp;lt;author_article />
    &amp;lt;yield select="?x:*" />
  &amp;lt;/yield>

  &amp;lt;yield name="author_article">
    &amp;lt;h1 bind="?title" id="title_(?id)" />
    &amp;lt;ul bind="?author">&amp;lt;li bind="?name" />&amp;lt;/ul>
  &amp;lt;/yield>
&amp;lt;/definition></code></pre>
  <p>Nous pouvons imaginer <strong>partager</strong> des bibliothèques entre
  <strong>plusieurs applications</strong> facilement ou même au sein d'une même
  application. La <strong>maintenance</strong> des composants graphiques se voit
  <strong>facilitée</strong> car tout est <strong>centralisé</strong> et
  facilement accessible. La <strong>composition</strong> des composants avec la
  <strong>propagation</strong> des liages vers les données offre un mécanisme
  puissant. L'<strong>abstraction</strong> des données par leur caractère
  symbolique empêche des regressions.</p>

  <h2 id="Acces_ressources" for="main-toc menu-toc">Accès aux ressources</h2>

  <p>Un système d'interface graphique doit faciliter l'accès aux
  <strong>ressources</strong> manipulées par une vue : des feuilles de style,
  des médias (images, vidéos, …), des polices, des scripts etc. Dans Hoa il
  existe plusieurs mécanismes que nous connaissons déjà bien, comme le routeur
  ou le protocole <code>hoa://</code>. Étudions comment XYL les utilise.</p>

  <h3 id="Routeur_et_liens" for="main-toc">Routeur et liens</h3>

  <p>Nous avons appris qu'une vue au sens de <code>Hoa\View\Viewable</code>
  comporte un <strong>routeur</strong>. Comme <code>Hoa\Xyl</code> implémente
  cette interface, nous pouvons définir et utiliser un routeur au sein de nos
  documents XYL.</p>
  <p>Nous allons commencer par écrire une règle sur un routeur HTTP et le donner
  à notre instance de XYL. La règle aura pour identifiant <code>blog</code> et
  n'aura aucune action (<ie /> <em>callable</em>) attachée — nous voulons juste
  écrire un lien, c'est à dire le <strong>dérouter</strong> — , ainsi :</p>
  <pre><code language="php">from('Hoa')
-> import('Router.Http')
-> import('File.Read')
-> import('Http.Response.~')
-> import('Xyl.~')
-> import('Xyl.Interpreter.Html.~');

$router = new Hoa\Router\Http();
$router->get('blog', '/Blog/(?&amp;lt;id>\d+)-(?&amp;lt;title>[^\.]+)\.html');

$xyl    = new Hoa\Xyl(
    new Hoa\File\Read('Main.xyl'),
    new Hoa\Http\Response(),
    new Hoa\Xyl\Interpreter\Html(),
    $router
);
$xyl->render();</code></pre>
  <p>Pour utiliser cette règle dans XYL, il faut tout d'abord se placer dans un
  attribut qui se comporte comme un <strong>lien</strong> (par exemple
  <code>href</code> pour le composant <code>a</code>, <code>src</code> pour le
  composant <code>img</code> etc.) et utiliser le formalisme suivant pour
  déclarer le lien :
  <code>@<em>anId</em>:<em>key</em>=<em>value</em>[&amp;amp;<em>key</em>=<em>value</em>]*</code>.
  Chaque <code><em>key</em></code> correspond à une <strong>variable</strong> de
  notre <strong>règle</strong> <code><em>anId</em></code> pour laquelle nous
  allons définir une <strong>valeur</strong> <code><em>value</em></code>. Ainsi,
  nous allons écrire le lien <code>@blog:id=42&amp;amp;title=Foobar</code> :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;p>This is a link to &amp;lt;a href="@blog:id=42&amp;amp;amp;amp;title=Foobar">an article in my
  blog&amp;lt;/a>!&amp;lt;/p>
&amp;lt;/document></code></pre>
  <p>Le contenu de l'attribut <code>href</code> vaudra
  <code>/Blog/42-Foobar.html</code> après interprétation. Notre lien est bien
  créé. Maintenant, si nous modifions la règle pour autre chose mais toujours
  avec les variables <code>id</code> et <code>title</code> placées différemment
  (par exemple
  <code>/Blog/Article-(?&amp;amp;lt;title>[^\.]+)-(?&amp;amp;lt;id>\d+)\.html</code>),
  nous verrons le lien se <strong>réécrire</strong> automatiquement. Amusez-vous
  à supprimer des variables de votre règle pour voir comment elle réagit ; le
  mécanisme est assez intuitif.</p>
  <p>Notons que le « <code>&amp;amp;amp;amp;</code> » est obligatoire car écrire
  simplement « <code>&amp;amp;</code> » serait une source d'erreur lors de
  l'analyse du document XYL (qui est du XML).</p>
  <p>Notons également que le routeur est reconnu par les
  <em>processing-instructions</em> de XYL, à savoir
  <code>&amp;amp;lt;?xyl-stylesheet?></code>,
  <code>&amp;amp;lt;?xyl-overlay?></code> et
  <code>&amp;amp;lt;?xyl-use?></code>.</p>
  <p>Enfin, si nous voulons écrire un lien à partir du routeur en étant en
  dehors d'un attribut, nous pouvons utiliser le composant <code>value</code> et
  son attribut <code>link</code> de cette manière :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;p>This is the link &amp;lt;value link="@blog:id=42&amp;amp;amp;amp;title=Foobar" />!&amp;lt;/p>
&amp;lt;/document></code></pre>

  <h3 id="Ressources_de_l-application_et_theme" for="main-toc">Ressources de
  l'application et thème</h3>

  <p>Le protocole <code>hoa://</code> définit plusieurs racines dont une
  destinée à l'application : <code>hoa://Application</code>. Sur cette racine,
  nous avons la branche <code>Public</code> qui donne accès aux données
  publiques de l'application, comme les feuilles de syles, les médias, les
  scripts etc. ; par exemple :
  <code>hoa://Application/Public/Css/UI.css</code>.</p>
  <p>Mais XYL définit la notion de <strong>thème</strong>. Un thème correspond à
  un <strong>habillage</strong>, avec ses <strong>comportements</strong>
  associés, spécifique pour notre interface graphique. Une application peut
  avoir plusieurs thèmes selon la plateforme ciblée (styles différents selon le
  système, la taille de l'écran, interface tactile ou pas etc.) ou selon les
  besoins de l'utilisateur (changements de couleurs, polices plus grosses
  etc.) : les raisons sont multiples.</p>
  <p>C'est pourquoi, après chaque branche <code>Public</code>, XYL va
  automatiquement <strong>insérer</strong> une branche correspond au thème
  <strong>courant</strong>. Le thème <strong>par défaut</strong> est
  <code>Classic</code>. Ainsi, le chemin
  <code>hoa://Application/Public/Css/UI.css</code> sera transformé en
  <code>hoa://Application/Public/<em>Classic</em>/Css/UI.css</code>.</p>
  <p>Mais XYL ne s'arrête pas là. Le protocole <code>hoa://</code> exprime un
  chemin <strong>côté serveur</strong>, mais pas <strong>client</strong>. C'est
  pourquoi, ce chemin est transformé en lien pour le routeur comme nous venons
  de le voir. XYL extrait trois données :
  <code>hoa://Application/Public/<em>theme</em>/<em>type</em>/<em>resource</em></code>
  et les réécrit en lien de la forme :
  <code>@_<em>type</em>:theme=<em>theme</em>&amp;amp;resource=<em>resource</em></code>.
  Seule la donnée <code><em>type</em></code> est mise en minuscule. Prenons un
  exemple : utiliser le lien <code>hoa://Application/Public/Css/UI.css</code>
  sera strictement équivalent à utiliser le lien
  <code>@_css:theme=Classic&amp;amp;resource=UI.css</code>. Puis dans notre
  routeur, définissons la règle suivante :</p>
  <pre><code language="php">$router->_get('_css', '/Assets/(?&amp;lt;theme>)/Style/(?&amp;lt;resource>)');</code></pre>
  <p>Côté <strong>client</strong>, nous aurons le lien : <code>/Assets/Classic/Style/UI.css</code>.</p>
  <p>Si la règle <code>_<em>type</em></code> n'existe pas dans le routeur, une
  règle par <strong>défaut</strong> sera utilisée : <code>_resource</code>. XYL
  l'ajoute sur le routeur automatiquement si elle n'est pas déjà présente et la
  donnée <code><em>resource</em></code> est préfixée de
  <code><em>type</em></code> pour éviter de perdre des données.</p>
  <p>Notons que nous avons préfixer la méthode <code>get</code> par le symbole
  « <code>_</code> ». Cela modifie la visibilité de la règle : elle n'est plus
  publique mais <strong>privée</strong>. Cela implique que cette règle ne sera
  jamais choisie pour faire du routage mais uniquement pour du
  <strong>déroutage</strong>.</p>
  <p>Enfin : il est préférable d'utiliser l'abstraction qu'offre le protcole
  <code>hoa://</code> car il ajoute le thème et peut-être d'autres choses à
  l'avenir.  Pour modifier le thème, il existe la méthode <code>setTheme</code>
  sur <code>Hoa\Xyl</code>. Nous privilégierons toujours la méthode
  <code>Hoa\Xyl::resolve</code> pour résoudre un chemin exprimé avec le
  protocole <code>hoa://</code> dans un contexte XYL au lieu d'utiliser
  simplement la fonction <code>resolve</code> (aliase de
  <code>Hoa\Core\Protocol::resolve</code>) car le thème sera pris en
  considération ainsi que d'autres fonctionnalités.</p>

  <h3 id="Ressources_des_bibliotheques" for="main-toc">Ressources des
  bibliothèques</h3>

  <p>XYL propose également des ressources utiles pour chaque interpréteur. Nous
  pouvons y accéder toujours grâce au protocole <code>hoa://</code> en utilisant
  la racine <code>Library</code> de cette manière :
  <code>hoa://Library/Xyl/Css/Core.css</code> par exemple.</p>
  <p>Chaque fichier <code>hoa://Library/Xyl/<em>resource</em></code> sera copié
  en <code>hoa://Application/Public/<em>resource</em></code> s'il n'existe pas
  (normalement, cette opération ne s'effectue qu'une seule fois). Ensuite, le
  lien <code>hoa://Application/Public/<em>resource</em></code> sera transformé
  comme nous venons de le voir.</p>
  <p>Actuellement, XYL ne propose que très peu de ressources et elles ne sont
  pas encore finalisées. Cette section sera mise à jour en temps voulu.</p>

  <h2 id="Application_Gordon-s_blog" for="main-toc menu-toc">Application :
  <em>Gordon's blog</em></h2>

  <p>Nous allons donner au <em>Gordon's blog</em> une meilleure interface
  graphique afin de pouvoir l'afficher dans un navigateur. Nous allons commencer
  par déclarer les vues puis les attacher à nos données à travers notre
  contrôleur pour enfin tester le tout.</p>

  <h3 id="Document_principal" for="main-toc">Document principal</h3>

  <p>Notre document principal sera <code>Application/View/Main.xyl</code> et
  accueillera nos différentes pages. Chaque page sera un <em>overlay</em> par
  rapport à ce document principal, il faudra donc préciser un identifiant.
  Ainsi :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>&amp;lt;value bind="?title" /> — Gordon's blog&amp;lt;/title>

  &amp;lt;header>
    &amp;lt;h1>Gordon's blog&amp;lt;/h1>
  &amp;lt;/header>

  &amp;lt;div id="main" />

  &amp;lt;footer>
    &amp;lt;p>Author: Gordon Freeman © 1999-2001. This blog is powered by
    &amp;lt;a href="http://hoa-project.net/">Hoa&amp;lt;/a> and
    &amp;lt;a href="http://php.net/">PHP&amp;lt;/a>.&amp;lt;/p>
  &amp;lt;/footer>
&amp;lt;/document></code></pre>
  <p>C'est un document très simple. Le titre est variable et nos pages
  s'ajouteront dans le composant portant l'identifiant <code>main</code>.</p>

  <h3 id="Liste_des_articles" for="main-toc">Liste des articles</h3>

  <p>Nous proposons de ranger les vues du blog dans le dossier
  <code>Application/View/Blog/</code>. Ainsi, la liste des articles sera
  représentée par le fichier <code>Index.xyl</code> et va définir un
  <em>overlay</em> pour l'identifiant <code>main</code> :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;div id="main">
    &amp;lt;p>Here is the list of all articles I have written:&amp;lt;/p>
    &amp;lt;ul>
      &amp;lt;li bind="?articles">
        &amp;lt;value bind="?posted" /> — &amp;lt;a href="@a:id=(?id)" bind="?title" />
      &amp;lt;/li>
    &amp;lt;/ul>
  &amp;lt;/div>
&amp;lt;/overlay></code></pre>
  <p>Nous avons une liste qui va s'accrocher sur les arbres
  <code>articles</code> et les feuilles de ces arbres vont servir à afficher la
  date, le lien et le titre des articles. Pour écrire le lien, nous utilisons la
  règle <code>a</code> définit dans notre routeur pour accéder à un article.</p>

  <h3 id="Un_article_avec_ses_commentaires" for="main-toc">Un article avec ses
  commentaires</h3>

  <p>Maintenant, nous allons écrire la vue d'un article dans le fichier
  <code>Article.xyl</code>, toujours en tant qu'<em>overlay</em>. Elle affichera
  le titre de l'article, son contenu et les commentaires associés. Nous avons
  fait le choix de définir un composant pour représenter les commentaires sous
  le nom <code>comment</code> et défini dans le fichier
  <code>Comment.xyl</code>. Ainsi :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-use href="hoa://Application/View/Blog/Comment.xyl"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;div id="main">
    &amp;lt;p>&amp;lt;a href="@i">☜ Back to list&amp;lt;/a>&amp;lt;/p>

    &amp;lt;yield bind="?article">
      &amp;lt;h2 bind="?title" />
      &amp;lt;p bind="?content" />
    &amp;lt;/yield>

    &amp;lt;h2>Comments&amp;lt;/h2>
    &amp;lt;comment bind="?comments" />
  &amp;lt;/div>
&amp;lt;/overlay></code></pre>
  <p>Les données concernant l'article se trouvent dans l'arbre
  <code>article</code> et les commentaires dans les arbres
  <code>comments</code>. Nous noterons le lien pour revenir à la liste des
  articles basé sur la règle <code>i</code> du routeur qui ne comporte aucune
  variable d'où sa grande simplicité.</p>
  <p>Et la déclaration de notre composant <code>comment</code> se fait de la
  manière suivante :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;definition xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;yield name="comment">
    &amp;lt;div class="comment">
      &amp;lt;ul>
        &amp;lt;li>
          &amp;lt;span bind="?posted" /> • &amp;lt;span bind="?author" />
          &amp;lt;p bind="?content" />
        &amp;lt;/li>
      &amp;lt;/ul>
    &amp;lt;/div>
  &amp;lt;/yield>
&amp;lt;/definition></code></pre>
  <p>Une fois de plus, les données nécessaires se devinent rapidement.</p>

  <h3 id="Depuis_notre_controleur" for="main-toc">Depuis notre contrôleur</h3>

  <p>Nous allons modifier nos deux méthodes de notre contrôleur
  <code>Application\Controller\Blog</code>, respectivement
  <code>IndexAction</code> pour la liste des articles et
  <code>ArticleAction</code> pour un seul article. Les données sont déjà
  extraites, nous allons les donner à XYL. Commençons par
  <code>IndexAction</code> :</p>
  <pre><code language="php">public function IndexAction ( ) {

    $article              = new \Application\Model\Article();
    $list                 = $article->getShortList();
    $this->data->title    = 'All articles';
    $this->data->articles = $list;

    $this->view->addOverlay('hoa://Application/View/Blog/Index.xyl');
    $this->view->render();

    return;
}</code></pre>
  <p>Nous déclarons deux données : le titre du document principal et la liste
  des articles. Puis, nous demandons à la vue d'utiliser l'<em>overlay</em>
  correspondant à la liste des articles et d'en faire un rendu. Nous remarquons
  que <code>Hoa\Core\Data</code> représenté par l'attribut <code>data</code>
  comprend bien les données provenant des bases de données (entre autres) : nous
  lui donnons <code>$list</code> sans effectuer aucune opération.</p>
  <p>Le traitement sera similaire pour un article et ses commentaires :</p>
  <pre><code language="php">public function ArticleAction ( $id ) {

    $article              = new \Application\Model\Article();
    $article->id          = $id;
    $article->open();
    $this->data->title    = $article->title;
    $this->data->article  = $article;
    $this->data->comments = $article->comments;

    $this->view->addOverlay('hoa://Application/View/Blog/Article.xyl');
    $this->view->render();

    return;
}</code></pre>
  <p>Encore une fois, en plus de <code>Hoa\Database\Dal</code>,
  <code>Hoa\Core\Data</code> comprend bien les données provenant de
  <code>Hoa\Model</code>. En réalité, <code>Hoa\Core\Data</code> ne connaît pas
  <code>Hoa\Model</code> et ne s'y adapte pas, mais c'est <code>Hoa\Model</code>
  qui s'y adapte et comme <code>Hoa\Xyl</code> utilise
  <code>Hoa\Core\Data</code>, le lien se fait par transitivité. Cette couche du
  noyau est très utile pour ce genre de manipulation de données et offre
  d'excellents résultats en plus d'excellentes performances.</p>

  <h3 id="Testons" for="main-toc">Testons !</h3>

  <p>Avant de tester, nous devons modifier notre fichier d'amorçage
  <code>index.php</code> pour préciser à notre dispatcheur en second argument
  qu'il doit utiliser <code>Hoa\Xyl</code> comme vue :</p>
  <pre><code language="php">from('Hoa')
-> import('Database.Dal')
-> import('Dispatcher.Basic')
-> import('Router.Http')
-> import('Xyl.~')
-> import('Xyl.Interpreter.Html.~')
-> import('File.Read')
-> import('Http.Response');

Hoa\Database\Dal::initializeParameters(array(
    'connection.list.default.dal' => Hoa\Database\Dal::PDO,
    'connection.list.default.dsn' => 'sqlite:hoa://Data/Variable/Database/Blog.sqlite',
    'connection.autoload'         => 'default'
));

$dispatcher = new Hoa\Dispatcher\Basic();
$router     = new Hoa\Router\Http();
$router->get('i', '/', 'blog', 'index')
       ->get('a', '/article-(?&amp;lt;id>\d+)\.html', 'blog', 'article');

try {

    $dispatcher->dispatch(
        $router,
        new Hoa\Xyl(
            new Hoa\File\Read('hoa://Application/View/Main.xyl'),
            new Hoa\Http\Response(),
            new Hoa\Xyl\Interpreter\Html(),
            $router
        )
    );
}
catch ( Hoa\Router\Exception\NotFound $e ) {

    echo 'Your page seems to be not found /o\.', "\n";
}</code></pre>
  <p>Maintenant, utilisons Bhoa pour exécuter notre application :</p>
  <pre><code language="shell">$ myapp bhoa --root hoa://Application/Public</code></pre>
  <p>Puis, depuis un navigateur en allant sur
  <a href="http://127.0.0.1:8888/"><code>127.0.0.1:8888</code></a>, nous verrons
  notre document rendu en HTML et plus précisément la liste des articles
  présents sur le blog. De même en allant sur
  <a href="http://127.0.0.1:8888/article-0.html"><code>127.0.0.1:8888/article-0.html</code></a>
  nous verrons le premier article du blog.</p>
  <p>Notons que les dates s'affichent toujours en format timestamp. Nous verrons
  comment résoudre ce problème sans passer par le contrôleur mais avec XYL
  uniquement.</p>

  <h3 id="Avec_des_ressources">Avec des ressources</h3>

  <p>Quelques styles, images, polices etc. sont disponibles sur
  <a href="http://hg.hoa-project.net/Sandbox">le dépôt <code>Sandbox/</code></a>
  dans le dossier <code>GordonsBlog/Application/Public/Classic/</code>. Nous
  pouvons les copier dans notre même dossier
  <code>Application/Public/Classic/</code>. Pour les utiliser, nous allons
  ajouter la feuille de style <code>Css/UI.css</code> à notre document
  principal :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-stylesheet href="hoa://Application/Public/Css/UI.css"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>&amp;lt;value bind="?title" /> — Gordon's blog&amp;lt;/title>
  …</code></pre>
  <p>Si nous retournons sur notre application, nous verrons que les styles sont
  appliqués !</p>
  <p>Une fois de plus, nous avons une bibliothèque qui introduit la dernière des
  trois couches principales dans notre application, ce qui nous approche du
  modèle de conception MVC. Nous noterons que toutes les couches sont des
  bibliothèques totalement <strong>découplées</strong> et donc
  <strong>interchangeables</strong> sans problème. Si XYL n'est pas nécessaire,
  nous pouvons le remplacer par un autre système d'interface graphique sans
  aucune impact sur notre architecture.</p>
  <p>Dans ce chapitre nous n'avons fait qu'effleurer les possibilités qu'offre
  XYL : les formulaires, la gestion de l'asynchrone, l'exécution des composants
  etc. vont être détaillés dans les prochains chapitres.</p>

  <ul class="prev_next">
    <li><a href="@ll:chapter=Model"><previous_chapter /> Modèle de
        données</a></li>
    <li>??? <next_chapter/></li>
  </ul>

</yield>
</definition>
